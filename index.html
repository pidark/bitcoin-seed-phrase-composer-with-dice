<html>
    <head>
        <title>Seed Phrase Composer</title>
        <!--

               ____  _         _
              / ___|| |_ _   _| | ___
              \___ \| __| | | | |/ _ \
               ___) | |_| |_| | |  __/
              |____/ \__|\__, |_|\___|
                         |___/

        -->
        <style>
            body {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                text-align: center;
            }
            #config, .testing {
                text-align: right;
            }
            span, input, button, select {
                margin: 5px;
                padding: 5px;
                display: inline-block;
            }
            input {
                width: 50px;
            }
            .diceInput, .selected {
              background-color: rgba(0, 128, 0, 0.25);
              font-weight: bold;
            }
            #selected9, #selected10, #selected11, #selected12 {
              background-color: rgba(0, 64, 0, 0.25);
            }
            .lastSelected {
              color: white;
            }
            table {
                margin: auto;
                border: 1px solid gray;
                table-layout: fixed;
                width: 100%;
                height: 52px; 
                font-size: 10px;
            }
            td {
              vertical-align: top;
              min-height: 17px;
            }
            .finalTable table, #about table  {
              width: auto;
            }
            #about #table-about-1 {
              width: 800px;
            }
            #table-about-1 td {
                margin: 5px;
                padding: 5px;
            }

            #exampreTable table {
              margin: auto;
            }
            #words {
                width: 100%;
            }
            #instruction {
                background-color: yellow;
            }
            #header {
                color: red;
            }
            #sticky {
              position: sticky;
              top:0;
              background-color: white;
            }
        </style>
    </head>
    <!--
     ____            _
    | __ )  ___   __| |_   _
    |  _ \ / _ \ / _` | | | |
    | |_) | (_) | (_| | |_| |
    |____/ \___/ \__,_|\__, |
                       |___/
    -->
    <body>
      <div id="header">
        <span>
          Your browser appears to be connected to some network!!!<br>
          This page is designed to be used on an offline and fully secure computer. <br>
          You can try it out in online mode, but before using it for amounts you are not ready to lose, you should go offline.
        </span>
        <br>
        <a href="https://github.com/n3s1us/bitcoin-seed-phrase-composer-with-dice">Go to readme</a>
      </div>
      <div id="config">
          <button onclick="location.reload();">RESET ALL</button>
          <br>
          Number of faces of the dice 
          <select id="diceFace" onchange="buildRolls();build();buildAbout();">
            <option value="2">2-sided die (a coin)</option>
            <option value="4">4-sided die</option>
            <option value="6" selected="selected">6-sided die (a regular dice)</option>
            <option value="8">8-sided die</option>
            <option value="16">16-sided die</option>
          </select>
      <br>
      </div>
      <br>
      <span id="about"></span>
      <br>
      <div class="testing">
        <button id="virtualDice" onclick="virtualDice()">Generate Random Number (Virtual Dice For Test ONLY!!!)</button>
        <br>
        <button id="generateSample" onclick="generateSample()">Generate Sample 23 words (For Test ONLY!!!)</button>
    </div>
      <div id="sticky">
        <span id="instruction"></span>
          <br>
          <span id="rolls">
        </span>
        <span>
          <button id="extractWord" onclick="extractWord()">Extract the word</button>
        </span>
        <br>
        <div class="testing">
        </div>
        <input id="words" onkeyup="updateExtractedCount()" autocomplete="off">
      </div>
      <span id="wordNumber">Extracted words: 0/24</span>
      <br>
      <br>     
      <span id="messageChecksum"></span>
      <br>
      <div id="container">
          Table of Words!
      </div>
    </body>
    <!--
       _                                _       _
      (_) __ ___   ____ _ ___  ___ _ __(_)_ __ | |_
      | |/ _` \ \ / / _` / __|/ __| '__| | '_ \| __|
      | | (_| |\ V / (_| \__ \ (__| |  | | |_) | |_
     _/ |\__,_| \_/ \__,_|___/\___|_|  |_| .__/ \__|
    |__/                                 |_|
    -->
    <script>
      //  _           _ _     _              __                  _   _
      // | |__  _   _(_) | __| | ___ _ __   / _|_   _ _ __   ___| |_(_) ___  _ __  ___
      // | '_ \| | | | | |/ _` |/ _ \ '__| | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
      // | |_) | |_| | | | (_| |  __/ |    |  _| |_| | | | | (__| |_| | (_) | | | \__ \
      // |_.__/ \__,_|_|_|\__,_|\___|_|    |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
      const bip39 = require('bip39');
      

      window.addEventListener("load", function(){
        buildRolls()
        build()
        buildAbout()
      });

      var startInstruction = `Roll the dice and put the numbers in the colored boxes! Then click "Extract the word"`

      var rolls, diceFace
      function buildRolls(nWords = 2048, cb = "updateSelection()") {
        diceFace = parseInt(document.getElementById("diceFace").value)

        if( diceFace < 2 ) {
          document.getElementById("instruction").innerHTML = `Möbius strip not allowed ;D Change number on Dice Face!`
          document.getElementById("instruction").style.backgroundColor = "red"
          return
        } else {
          document.getElementById("instruction").innerHTML = startInstruction
          document.getElementById("instruction").style.backgroundColor = "yellow"
        }

        for(rolls=1; true; rolls++) {
          nWords = nWords / diceFace
          if (nWords <= 1) break
        }

        let html = ''
        for (let i=1; i<=rolls; i++) {
          html += `<input id="diceInput${i}" class="diceInput" type="number" min="1" max="${diceFace}" onkeyup="${cb}" onchange="${cb}">`
        }
        document.getElementById("rolls").innerHTML = html
      }

      function createQuadrant(nCells, perrow, arr = bip39.wordlists.EN, iMax = 2592, tableClass, i = 0, step = 1, html = '') {
        let tableBody = ""
        while (i<nCells*step) {
          tableBody += `<td id="${tableClass}-${i+1}" class="${tableClass}">${ arr[i] ? arr[i] : '' }</td>`
          // Break into next row
          var next = i+1
          if (next%perrow == 0) { 
            tableBody += next!=nCells ? `</tr><tr>` : `</tr>`
          }
          i++
        }
        html = `${html? html+'<br>' : html}<table id="table-${tableClass}-${step}"><tr>${tableBody}</table>`
        html += ""

        step++
        if( i >= iMax ) {
          return html
        } else {
          return createQuadrant(nCells, perrow, arr, iMax, tableClass, i, step, html)
        }
      }

      function build(prefix = 'dice', words = bip39.wordlists.EN) {
          let firstPerrow = 2
          if (diceFace == 2) firstPerrow = 1
          if (diceFace == 4) firstPerrow = 1
          if (diceFace == 16) firstPerrow = 4

          let perrow = 2
          if (diceFace == 16) perrow = 2

          let lastPerrow = 2
          if (diceFace == 8) lastPerrow = 4
          if (diceFace == 16) lastPerrow = 4

          let evenPerrow = 2 /* only with a coin */                

          const nCells = diceFace 
          
          let x,y
          if ( diceFace == 6 ) x = 2, y = 3
          else if ( diceFace == 16 ) x = 8, y = 2
          else if ( diceFace == 8 ) x = 4, y = 2
          else if ( diceFace == 4 ) x = 2, y = 2
          else if ( diceFace == 2 ) x = 2, y = 1


          let html
          for(let i = rolls; i!=0; i--) {
            if ( i == rolls ) {
              html = createQuadrant(nCells, firstPerrow, words, (x**i)*(y**(i-1)), `${prefix}${i}`)
            } else {
              if( i == 1 ) perrow = lastPerrow
              if( diceFace == 2 ) perrow = i % 2 == 0 ? evenPerrow : firstPerrow
              html = createQuadrant(nCells, perrow, html.split("<br>"), (x**i)*(y**(i-1)), `${prefix}${i}`)
            }
          }
          document.getElementById("container").innerHTML = html
      }

      function buildAbout() {
        const about = `
          <b>About</b><br>
          This is a way to generate a (BIP-39) seed for a bitcoin wallet, completely offline, using a ${diceFace == 2 ? 'coin' : diceFace+'-sided die'}, with a fully verifiable source of entropy.<br>
          <br>
          Each quadrant is divided into ${diceFace} large rectangles, each of those into ${diceFace} smaller ones and each of those into ${diceFace} even smaller ones. You use a dice to "drill down" until you reach a word.<br>
          <br>
          You can use this method to get the first 23 words of your seed but because the 24th word cointains a checksum it has to be calulated a finally extract the last 24h possibile words in same manner of the previus.<br>
          <br>
          <b>How to use?</b><br>
          This tool is simply a single file web page using javascript for calculations, that can be downloaded and used offline (right click "Save as...""). <br>
          <br>
          For example you can use it on any Linux Live from a USB stick and NEVER connect this Linux Live to internet neither before nor after!<br>
          <br>
          <b>Using more ${diceFace == 2? 'coin': 'dice'} instead of one</b><br>
          <rb>
          If you wanna speed up the process by using more ${diceFace == 2? 'coin': 'dice'} instead of one you need to make sure that you read the results in a predetermined order (so that your own brain is not involved in the process of deciding which ${diceFace == 2? 'coin': 'dice'} should be read first).<br>
          <br>
          The simplest way to do this is to always read the from left to right as they land on the table. Another option would be to use differently colored ${diceFace == 2? 'coin': 'dice'} and decide that the red one is the first one, the blue one is the second etc.`
        let algorithm = `
          <b>Algorithm</b><br>
          <br>
          A round of selection has the following rules:<br>
          <br>
          ${diceFace == 2 ? 'Odd': 'First'} roll of die, this tool select corresponding large rectangle according to:<br>
          <br>
          <div id="exampleTableFirst"></div>
          <br>
          ${diceFace == 2 ? 'Even': 'Other'} die rolls, this tool select corresponding large rectangle according to:<br>
          <br>
          <div id="exampleTableOther"></div>
          <br>
          Repeat previous step more times, selecting smaller rectangles within the current one until you get a single word.<br>`

          if(diceFace == 4) {
            algorithm += `
            <br>
            Last roll of die, this tool selecting the word according to:<br>
            <br>
            <div id="exampleTableLast"></div>`
          }

          algorithm += `
          <br>
          - Repeat step rounds of selection until you  23 words<br>`

          if(diceFace == 6) {
            algorithm += `- If final rectangle is empty, you have to <u>start the round from scratch</u><br>`
          }

        
        let html, perrow
        /* About Table */
        html = createQuadrant(2, 2, [about, algorithm], 2, `about`)
        document.getElementById("about").innerHTML = `<button id="toggleAbout" onclick="toggleAbout()">Hide About</button><br><br><div id="aboutContent">${html}</div>`
        
        /* First Example Table */
        let d = 2
        perrow = 2
        let arr = []
        if( diceFace == 2 ) d = 2, perrow = 1
        if( diceFace == 8 ) d = 4, perrow = 4
        if( diceFace == 16 ) d = 8, perrow = 4
        for( let i = 1; i<=d; i++) {
          const preText = diceFace == 2 ? '' : `${diceFace/d*(i-1)+1}-`
          arr.push(createQuadrant(2, 2, [`${preText}${diceFace/d*i}<br>quadrant ${i}`], 2, `quadrant${i}`))
        }
        html = createQuadrant(d, perrow, arr, d, `exampleTableFirst`)
        document.getElementById("exampleTableFirst").innerHTML = html

        /* Other Example Table */
        arr = []
        for(let i = 1; i <= diceFace; i++) arr.push(i)
        perrow = 2 
        if(diceFace == 16) perrow = 4 
        html = createQuadrant(diceFace, perrow, arr, 2, `exampleTableOther`)
        document.getElementById("exampleTableOther").innerHTML = html

        /* Last Example Tablet*/
        if (diceFace == 4) {
          perrow = 1
          html = createQuadrant(diceFace, perrow, arr, 2, `exampleTableLast`)
          document.getElementById("exampleTableLast").innerHTML = html
        }
        
      }

      function toggleAbout() {
        if (document.getElementById("aboutContent").style.display == 'none') {
          buildAbout()
        } else {
          document.getElementById("aboutContent").style.display = "none"
          document.getElementById("toggleAbout").innerHTML = "Show About"
        }

      }


      //           _           _   _                __                  _   _
      //  ___  ___| | ___  ___| |_(_) ___  _ __    / _|_   _ _ __   ___| |_(_) ___  _ __  ___
      // / __|/ _ \ |/ _ \/ __| __| |/ _ \| '_ \  | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
      // \__ \  __/ |  __/ (__| |_| | (_) | | | | |  _| |_| | | | | (__| |_| | (_) | | | \__ \
      // |___/\___|_|\___|\___|\__|_|\___/|_| |_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/

      function validateDice(i) {
          let n = parseInt(document.getElementById(`diceInput${i}`).value)
          if( !n ) return false
          if ( n < 1 || n > diceFace ) {
              document.getElementById("instruction").innerHTML = `All the colored box should be filled with a number from 1 to ${diceFace}!`
              document.getElementById("instruction").style.backgroundColor = "red"
              return false
          }
          document.getElementById("instruction").innerHTML = startInstruction
          document.getElementById("instruction").style.backgroundColor = "yellow"
          return true
      }
      function updateSelection(prefix = 'dice', words = bip39.wordlists.EN) {
        build(prefix, words)
        for (let i=1; true; i++) {
          let e = document.getElementById(`diceInput${i}`)
          if (!e || !validateDice(i)) return
          let n = e.value
          if( i==1 ) {
            if ( diceFace < 8) {
              n = n <= diceFace/2 ? 1 : 2
            } else {
              words.length == diceFace? n = n : n = Math.ceil(n/2)
            }

            document.getElementsByClassName(`${prefix}${i}`)[n-1].id = `selected${i}`
            document.getElementById(`selected${i}`).classList.add("selected")
            document.getElementById(`selected${i}`).scrollIntoView({behavior: "smooth", block: "center", inline: "nearest"})
          } else {
            document.getElementById(`selected${i-1}`).getElementsByClassName(`${prefix}${i}`)[n-1].id = `selected${i}`
            document.getElementById(`selected${i}`).classList.add("selected")
            document.getElementById(`selected${i}`).scrollIntoView({behavior: "smooth", block: "center", inline: "nearest"});
            if ( i == rolls ) document.getElementById(`selected${i}`).classList.add("lastSelected")
          }
        }
      }

      function extractWord(nWords = 2048, cb = "updateSelection()", prefix = 'dice', words = bip39.wordlists.EN) {
          document.getElementById("wordNumber").scrollIntoView({behavior: "smooth", block: "center", inline: "nearest"})

          let word = document.getElementById(`selected${rolls}`)
          if( !word ) {
            document.getElementById("instruction").innerHTML = "All the colored box should be fullfilled!"
            document.getElementById("instruction").style.backgroundColor = "red"
            return
          }
          
          buildRolls(nWords, cb)
          build(prefix, words)       

          if ( !word.innerHTML ) {
              document.getElementById("instruction").innerHTML = "Selection empty, throw your dates again to make a round from scratch so that every word has the same probabilities!"
              document.getElementById("instruction").style.backgroundColor = "yellow"
          } else {
              document.getElementById("words").value += !document.getElementById("words").value ? word.innerHTML : " " + word.innerHTML
              updateExtractedCount(word)
          }
      }

      function updateExtractedCount(word) {
          let nWords = document.getElementById("words").value.split(" ").length
          document.getElementById("wordNumber").innerHTML = `Extracted words: ${nWords}/24`

          let instruction
          if (nWords == 23) {
              instruction = 'Now you can click "Calculate Last 24th Word"!'
              document.getElementById("instruction").style.backgroundColor = "yellowgreen"
              document.getElementById("extractWord").setAttribute('onclick','lastWords()')
              document.getElementById("extractWord").innerHTML = 'Calculate Last 24th Words'
              document.getElementById("rolls").style.visibility = "hidden";
              document.getElementById("rolls").innerHTML = "";
              document.getElementById("container").style.visibility = "hidden";
          } else if (nWords == 24) {
            document.getElementById("instruction").style.backgroundColor = "yellowgreen"
            instruction = `Last 24th word "${word.innerHTML}" extracted! Mission Complete`

            document.getElementById("messageChecksum").innerHTML = `The  24th words are: <br><br> Recap of all you words is: <br><span><b>${document.getElementById("words").value}</b></span>`  
            document.getElementById("messageChecksum").style.backgroundColor = "yellowgreen"
            
            document.getElementById("rolls").style.visibility = "hidden";
            document.getElementById("extractWord").style.visibility = "hidden";
            document.getElementById("virtualDice").style.visibility = "hidden";
            document.getElementById("generateSample").style.visibility = "hidden";
            showPubKeys()
            
          } else {
              if(word) {
              instruction = `Word "${word.innerHTML}" extracted! Rolls again your dice to pick another one!`
              document.getElementById("instruction").style.backgroundColor = "aquamarine"
              } else {
                instruction = startInstruction
                document.getElementById("instruction").style.backgroundColor = "yellow"
              }
              document.getElementById("extractWord").setAttribute('onclick','extractWord()')
              document.getElementById("extractWord").innerHTML = 'Extract the Word'

              
              document.getElementById("rolls").style.visibility = "visible";
              document.getElementById("container").style.visibility = "visible";
              buildRolls()
              build()
          }
          document.getElementById("instruction").innerHTML = instruction
      }

      //  _           _                           _    __                  _   _
      // | | __ _ ___| |_  __      _____  _ __ __| |  / _|_   _ _ __   ___| |_(_) ___  _ __  ___
      // | |/ _` / __| __| \ \ /\ / / _ \| '__/ _` | | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
      // | | (_| \__ \ |_   \ V  V / (_) | | | (_| | |  _| |_| | | | | (__| |_| | (_) | | | \__ \
      // |_|\__,_|___/\__|   \_/\_/ \___/|_|  \__,_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/


      let checksumWords
      function lastWords() {
        const validation = validate(document.getElementById("words").value)
        if ( validation.errorMessage ) {
          document.getElementById("messageChecksum").innerHTML = validation.errorMessage
          document.getElementById("messageChecksum").style.backgroundColor = "red"
        } else {
          checksumWords = allChecksumWords(validation.cleanedUpPhrase)
          
          document.getElementById("rolls").style.visibility = "visible";
          document.getElementById("container").style.visibility = "visible";
          buildRolls(checksumWords.length, "updateLastSelection()")
          build('lastRound', checksumWords)

          document.getElementById("container").classList.add('finalTable')
          document.getElementById("messageChecksum").innerHTML = 'The last possibile 24th words are:'  
          document.getElementById("messageChecksum").style.backgroundColor = "white"
          document.getElementById("extractWord").setAttribute('onclick','extractLastWord()')
          document.getElementById("extractWord").innerHTML = 'Extract the last 24th word'
          document.getElementById("diceFace").disabled = "disabled"
          document.getElementById("words").disabled = "disabled"
        }
      }

      function updateLastSelection() {
        updateSelection('lastRound', checksumWords)
      }

      function extractLastWord() {
        extractWord(checksumWords.length, "updateLastSelection()", "lastRound", checksumWords)
      }

      function showPubKeys() {
        const words = document.getElementById("words").value
        const path = `m/84'/0'/0'/0`
        const xpub = xpubFromMnemonic(words, path)
        document.getElementById("container").innerHTML = `<h1>Public Keys</h1><h2>XPUB</h2><p><${xpub}</p>`
      }
            // document.getElementById("container").style.visibility = "hidden";

      //  _            _   _               _           _   _
      // | |_ ___  ___| |_(_)_ __   __ _  | |__  _   _| |_| |_ ___  _ __
      // | __/ _ \/ __| __| | '_ \ / _` | | '_ \| | | | __| __/ _ \| '_ \
      // | ||  __/\__ \ |_| | | | | (_| | | |_) | |_| | |_| || (_) | | | |
      // \__\___||___/\__|_|_| |_|\__, | |_.__/ \__,_|\__|\__\___/|_| |_|
      //                           |___/
      function getRandomInt(min, max) {
        max = parseFloat(max) + 1
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min)) + min; //Il max è escluso e il min è incluso
      }

      function virtualDice() {
        for (let i=1; true; i++) {
          if (!document.getElementById(`diceInput${i}`)) {
            !checksumWords ? updateSelection() : updateLastSelection()
            return
          }
          document.getElementById(`diceInput${i}`).value = getRandomInt(1, document.getElementById("diceFace").value)
        }
        !checksumWords ? updateSelection() : updateLastSelection()
      }

      Array.prototype.random = function () {
        return this[Math.floor((Math.random() * this.length))]
      }

      function generateSample() {
        const samplePhrase = [...Array(23).keys()]
          .map(() => bip39.wordlists.EN.random())
          .join(" ");
          document.getElementById("words").value = samplePhrase
          updateExtractedCount()
      }

      //  ____  _  _   _   _      __        __            _    ____ _               _
      // |___ \| || | | |_| |__   \ \      / /__  _ __ __| |  / ___| |__   ___  ___| | _____ _   _ _ __ ___
      //   __) | || |_| __| '_ \   \ \ /\ / / _ \| '__/ _` | | |   | '_ \ / _ \/ __| |/ / __| | | | '_ ` _ \
      //  / __/|__   _| |_| | | |   \ V  V / (_) | | | (_| | | |___| | | |  __/ (__|   <\__ \ |_| | | | | | |
      // |_____|  |_|  \__|_| |_|    \_/\_/ \___/|_|  \__,_|  \____|_| |_|\___|\___|_|\_\___/\__,_|_| |_| |_|


      function validate(suppliedSeedPhrase) {
        let wordCount = 0
        const trimmedWords = suppliedSeedPhrase
          .trim()
          .split(" ")
          .filter(word => word.length > 0)
          .map(word => word.trim())
          .map(word => word.toLowerCase())

        if (trimmedWords.length > 0) {
          wordCount = trimmedWords.length
        }
        if (wordCount !== 23) {
          const msg = "Please enter 23 words. (You entered " + wordCount + ")"
          return validationReply(msg)
        }
        const dictionary = bip39.wordlists[bip39.getDefaultWordlist()]
        const nonDictionaryWords =
          trimmedWords
            .map(word => dictionary.includes(word) ? "" : word)
            .filter(word => word.length > 0)
            .map(word => "'" + word + "'")
            .join(", ")
        if (nonDictionaryWords.length > 0) {
          const msg = "Words not in the dictionary: " + nonDictionaryWords
          return validationReply(msg)
        }
        return validationReply("", trimmedWords.join(" "))
      }

      function validationReply(errorMsg, words) {
          return {
              valid: errorMsg === "",
              errorMessage: errorMsg,
              cleanedUpPhrase: words
          }
      }

      function allChecksumWords(suppliedSeedPhrase) {
          return [...Array(2048).keys()]
              .map(wordOrBlank(suppliedSeedPhrase))
              .filter(word => word.length > 0)
      }

      function wordOrBlank(suppliedSeedPhrase) {
          return i => {
              const current = bip39.wordlists.EN[i]
              const candidate = suppliedSeedPhrase.trim().toLowerCase() + " " + current
              try {
                  bip39.mnemonicToEntropy(candidate)
                  return current
              } catch(e) {
                  return ""
              }
          };
      }
      //  ____        _       _  __
      // |  _ \ _   _| |__   | |/ /___ _   _ ___
      // | |_) | | | | '_ \  | ' // _ \ | | / __|
      // |  __/| |_| | |_) | | . \  __/ |_| \__ \
      // |_|    \__,_|_.__/  |_|\_\___|\__, |___/
      //                               |___/
      function xpubFromMnemonic(mnemonic, derivationPath) {
        const seed = bip39.mnemonicToSeedSync(mnemonic)
        const node = bip32.fromSeed(seed)
        const child = node.derivePath(derivationPath.full)
        return child.neutered().toBase58()
      } 

      /**
       * OFFLINE CHECK CONTROL
       */
      if(!navigator.onLine) {
        document.getElementById("header").style.display = "none"
      }
      </script>
      <!-- 
      
       _                                     _  __
      | |__  _ __ _____      _____  ___ _ __(_)/ _|_   _
      | '_ \| '__/ _ \ \ /\ / / __|/ _ \ '__| | |_| | | |
      | |_) | | | (_) \ V  V /\__ \  __/ |  | |  _| |_| |
      |_.__/|_|  \___/ \_/\_/ |___/\___|_|  |_|_|  \__, |
                                                  |___/

       _     _      _____ ___
      | |__ (_)_ __|___ // _ \
      | '_ \| | '_ \ |_ \ (_) |
      | |_) | | |_) |__) \__, |
      |_.__/|_| .__/____/  /_/
              |_|
       _     _      _________
      | |__ (_)_ __|___ /___ \
      | '_ \| | '_ \ |_ \ __) |
      | |_) | | |_) |__) / __/
      |_.__/|_| .__/____/_____|
              |_|

       _             ____   ___       _               _
      | |____      _| ___| ( _ )  ___| |__   ___  ___| | __
      | '_ \ \ /\ / /___ \ / _ \ / __| '_ \ / _ \/ __| |/ /
      | |_) \ V  V / ___) | (_) | (__| | | |  __/ (__|   <
      |_.__/ \_/\_/ |____/ \___/ \___|_| |_|\___|\___|_|\_\

      browserify -r bip32 -r bip39 -r bs58check

      -->
    <script>
      
    </script>
</html>